<html>
  <head>
    <title>L-Systems.JS Playground</title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script src="http://mrdoob.github.com/three.js/build/Three.js"></script>
    <script src="bootstrap.min.js"></script>
    <script src="lsys.js"></script>
    <link rel="stylesheet" href="bootstrap.css" type="text/css"/>
    <link rel="stylesheet" href="style.css" type="text/css"/>

    <link href="prettify.css" type="text/css" rel="stylesheet"/>
    <script type="text/javascript" src="prettify.js"></script>
  </head>

  <body onload="prettyPrint()">

    <div class="page">
      <div class="container">

        <div class="hero-unit">
          <h1>L-Systems.JS</h1>
          <p>Explore the power of L-Systems</p>
          <p>
            <a class="btn btn-large" href="lsys.js">Download L-Systems.JS</a>
            <a class="btn btn-primary btn-large" href="http://github.com/yuvadm/lsys.js">L-Systems.JS on Github</a>
          </p>
        </div>

        <h2>About</h2>
        <hr>
        <div class="row">
          <div class="span12">
            <p><b>L-Systems (short for Lindenmayer systems) are instances of a formal grammar that are used to model growth processes of plant deveopment. L-Systems can be used to generate realistic, natural-looking organisms in simulated environments.</b></p>

            <p>An L-System consists of an initial axiom string, for example: <code>F</code>, and a set of production rules, for example: <code>F -> F-F+FF</code>. The rules are used to iterativey expand the string to a larger one. In our example, two iterations on the string will yield the string <code>F-F+FF-F-F+FF+F-F+FFF-F+FF</code>. L-Systems also include a mechanism that converts the output string into a geometrical representation. The syntax includes:</p>

            <ul>
              <li><code>F</code> - a unit vector step forward that draws a line</li>
              <li><code>+</code>,<code>-</code>,<code>&</code>,<code>^</code>,<code>&lt;</code>,<code>&gt;</code> - left and right turns on all three axises</li>
              <li><code>|</code> - a vector direction flip</li>
              <li><code>[</code>, <code>]</code> - state push and pop functions that enable branch creation.
            </ul>

            <p>Proper cartesian coordinates can then be generated from the result string, for processing in the front-end of your choice (WebGL, canvas or SVG).
            </p>

            <p>L-Systems.JS was created by <a href="http://y3xz.com">Yuval Adam</a>.</p>
          </div>
        </div>

        <h2>Usage</h2>
        <hr>
        <div class="row">
          <div class="span12">
            <p>The canonical usage would be to create the L-System itself by defining the axiom string and the production rules, running the iteration, and generating the respective cartesian coordinates.</p>
            <pre class="prettyprint">
var lsys = new LSystem('F', { 'F': 'F-F+FF' });
var tree = lsys.iterate(2);
console.log(tree);  // F-F+FF-F-F+FF+F-F+FFF-F+FF
var coords = lsys.draw(Math.PI / 2);
console.log(coords);  // [[[0,0,0], [0,1,0], [1,1,0], ... ]]</pre>
            <p>These coordinates can now be plotted by any front-end. For example, using <a href="http://mrdoob.github.com/three.js/">THREE.js</a>:</p>
            <pre class="prettyprint">
for (var i=0; i&lt;coords.length; i++) {
  var branch = [];
  for (var j=0; j&lt;coords[i].length; j++) {
    branch.push(new THREE.Vector3(coords[i][j][0], coords[i][j][1], coords[i][j][2]));
  }
  var geometry = new THREE.Shape(branch).createPointsGeometry();
  console.log(geometry);
  draw_geometry(geometry);
}</pre>
          </div>
        </div>

        <h2>Playground</h2>
        <hr>
        <div class="row">
          <div class="span3">
            <ul class="nav nav-list"s>
              <li class="nav-header">Classic Trees</li>
              <li><a href="#">Tree 1</a></li>
              <li><a href="#">Tree 2</a></li>
              <li><a href="#">Tree 3</a></li>
            </ul>
          </div>
          <div class="span9">
            <div id="render-container"></div>
          </div>
        </div>

        <h2>Other</h2>
      </div>
    </div>

    <script>

      var WIDTH = 500; //window.innerWidth;
      var HEIGHT = 300; //window.innerHeight;

      var container;
      var scene, camera, renderer;
      var lsys_tree;

      var mouseX = 0, mouseY = 0;
      var windowHalfX = WIDTH / 2;
      var windowHalfY = HEIGHT / 2;

      init();
      draw_axes();
      draw_cube();
      var lsys = new LSystem('F', { 'F': 'F+F-F' });
      var tree = lsys.iterate(4);
      var coords = lsys.draw(Math.PI / 2);
      draw_lsys(coords);
      animate();

      function init() {
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(20, WIDTH / HEIGHT, 1, 10000);
        camera.position.y = 100;
        camera.position.z = 100;
        scene.add(camera);

        light = new THREE.DirectionalLight( 0xffffff );
        light.position.set( 0, 0, 1 );
        scene.add(light);

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setSize(WIDTH, HEIGHT);
        
        container = document.getElementById('render-container');
        container.appendChild(renderer.domElement);

        document.addEventListener('mousemove', onDocumentMouseMove, false);
      }

      function onDocumentMouseMove( event ) {
        mouseX = (event.clientX - windowHalfX);
        mouseY = (event.clientY - windowHalfY);
      }

      function draw_axes() {
        var home = new THREE.Vector3(0,0,0);

        var x_axis = [home, new THREE.Vector3(150,0,0)];
        var y_axis = [home, new THREE.Vector3(0,150,0)];
        var z_axis = [home, new THREE.Vector3(0,0,150)];

        var axis_geometry = [
          new THREE.Geometry(),
          new THREE.Geometry(),
          new THREE.Geometry()
        ];

        axis_geometry[0] = new THREE.Shape(x_axis).createPointsGeometry();
        axis_geometry[1] = new THREE.Shape(y_axis).createPointsGeometry();
        axis_geometry[2] = new THREE.Shape(z_axis).createPointsGeometry();

        var axis_material = [
          new THREE.LineBasicMaterial({ color : 0xff0000 }),
          new THREE.LineBasicMaterial({ color : 0x00ff00 }),
          new THREE.LineBasicMaterial({ color : 0x0000ff })
        ];

        var axis_line = [
          new THREE.Line(axis_geometry[0], axis_material[0]),
          new THREE.Line(axis_geometry[1], axis_material[1]),
          new THREE.Line(axis_geometry[2], axis_material[2])
        ];

        scene.add(axis_line[0]);
        scene.add(axis_line[1]);
        scene.add(axis_line[2]);
      }

      function draw_cube() {
        var materials = [];
        for (var i=0; i<6; i++) {
          materials.push(new THREE.MeshBasicMaterial({
            color : Math.random() * 0xffffff
          }));
        }

        var cube = new THREE.Mesh(new THREE.CubeGeometry(5, 5, 5, 1, 1, 1, materials), new THREE.MeshFaceMaterial());
        cube.position.x = 2.5;
        cube.position.y = 2.5;
        cube.position.z = 2.5;
        scene.add(cube);
      }

      function draw_lsys(coords) {
        lsys_tree = new THREE.Object3D();
        for (var i=0; i<coords.length; i++) {
          var branch = [];
          for (var j=0; j<coords[i].length; j++) {
            branch.push(new THREE.Vector3(coords[i][j][0], coords[i][j][1], coords[i][j][2]));
          }
          var geometry = new THREE.Shape(branch).createPointsGeometry();
          var material = new THREE.LineBasicMaterial({
            color : 0x111122,
            linewidth : 2
          });
          var line = new THREE.Line(geometry, material);
          lsys_tree.add(line);
        }
        scene.add(lsys_tree);
      }

      function animate() {
        requestAnimationFrame(animate);
        render();
      }

      function render() {
        lsys_tree.rotation.y = mouseX % (20 * Math.PI) / 10;
        camera.lookAt(scene.position);
        renderer.render(scene, camera);
      }

    </script>
  </body>
</html>
